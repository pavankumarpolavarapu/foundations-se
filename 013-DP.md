### The Complete Guide to Creational Design Patterns

Welcome to your focused training on Creational Design Patterns. Think of this as learning the different ways new things can be "born" in your software. The five patterns in this category are all about one thing: **controlling the object creation process.**

Instead of just using the `new` keyword everywhere (`new Car()`, `new User()`), which can make your code rigid and hard to change, these patterns give you flexible and powerful ways to create objects. This makes your system more adaptable and reusable.

Let's explore each of the five creational patterns.

---

### 1. The Singleton Pattern

*   **The Core Problem (The "Why"):** "I need to guarantee that a class has **only one instance** throughout my entire application, and I need a single, global way to access it."
*   **The Solution (The "How"):** The class itself is responsible for its own lifecycle. It has a `private` constructor to prevent anyone else from creating it, and a `public static` method that returns the single, internally managed instance.
*   **Analogy:** A country's central government. There can only be one. No matter how many people or agencies try to interact with "the government," they are all directed to the same, single entity.
*   **When to Use It:** For resources that are inherently singular, like a configuration manager, a logging service, or a database connection pool. Use it with caution, as global state can make testing more difficult.

**Code Example (Java):**

```java
// A ConfigurationManager that should only exist once.
public class ConfigurationManager {

    // 1. The static field to hold the single instance of the class.
    private static ConfigurationManager instance;

    // A private field to hold some data.
    private String databaseUrl;

    // 2. The private constructor prevents direct instantiation from outside.
    private ConfigurationManager() {
        // Simulate loading configuration from a file.
        this.databaseUrl = "jdbc:mysql://localhost/production_db";
        System.out.println("ConfigurationManager initialized.");
    }

    // 3. The public static method to get the one and only instance.
    public static ConfigurationManager getInstance() {
        // "Lazy initialization": create the instance only when it's first requested.
        if (instance == null) {
            instance = new ConfigurationManager();
        }
        return instance;
    }
    
    // A regular public method
    public String getDatabaseUrl() {
        return this.databaseUrl;
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     ConfigurationManager config1 = ConfigurationManager.getInstance();
//     System.out.println(config1.getDatabaseUrl());

//     ConfigurationManager config2 = ConfigurationManager.getInstance(); // This will NOT create a new object.
    
//     // Prove they are the same instance
//     System.out.println(config1 == config2); // Outputs: true
// }
```

---

### 2. The Factory Method Pattern

*   **The Core Problem (The "Why"):** "My parent class needs to create an object, but I want to let its subclasses decide which *specific type* of object to create."
*   **The Solution (The "How"):** Define an abstract method in the parent class for creating an object (the "factory method"). Each subclass then implements this method to return a specific type of object.
*   **Analogy:** A pizza franchise. The parent `PizzaStore` class has a process for ordering a pizza (`orderPizza()`), which includes a step to `createPizza()`. A `NYPizzaStore` subclass implements `createPizza()` to make a thin-crust pizza, while a `ChicagoPizzaStore` implements it to make a deep-dish pizza. The ordering process is the same, but the final product is different.
*   **When to Use It:** When you have a class that can't anticipate the class of objects it needs to create, or when you want to provide a hook for users of your framework to add their own custom objects.

**Code Example (Java):**
```java
// The "Product" interface
interface Document {
    void open();
}

// Concrete "Products"
class WordDocument implements Document {
    public void open() { System.out.println("Opening Word document..."); }
}
class PdfDocument implements Document {
    public void open() { System.out.println("Opening PDF document..."); }
}

// The abstract "Creator" (The Factory)
abstract class Application {
    // This is the Factory Method! It's abstract, forcing subclasses to implement it.
    public abstract Document createDocument();

    public void newDocument() {
        Document doc = createDocument();
        doc.open();
    }
}

// Concrete "Creators"
class WordApplication extends Application {
    @Override
    public Document createDocument() {
        return new WordDocument();
    }
}
class PdfApplication extends Application {
    @Override
    public Document createDocument() {
        return new PdfDocument();
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     Application wordApp = new WordApplication();
//     wordApp.newDocument(); // Outputs: "Opening Word document..."

//     Application pdfApp = new PdfApplication();
//     pdfApp.newDocument();  // Outputs: "Opening PDF document..."
// }
```

---

### 3. The Abstract Factory Pattern

*   **The Core Problem (The "Why"):** "I need to create *families* of related objects (e.g., a button, a checkbox, a window), but I want to ensure that the objects I create are all from the same family (e.g., all have a Windows look, or all have a macOS look) without hard-coding the specific family."
*   **The Solution (The "How"):** Provide an interface for creating families of related objects without specifying their concrete classes. Think of it as a "factory for factories."
*   **Analogy:** An IKEA furniture series. You have a `ModernFurnitureFactory` and a `VictorianFurnitureFactory`. The `ModernFurnitureFactory` creates a `ModernChair` and a `ModernTable`. The `VictorianFurnitureFactory` creates a `VictorianChair` and a `VictorianTable`. Your client code is configured with one of these factories and can ask for "a chair" and "a table," confident they will match stylistically.
*   **When to Use It:** When your system needs to be independent of how its products are created, composed, and represented, and when you need to work with one of several families of products.

**Code Example (Java):**
```java
// Abstract "Products"
interface Button { void paint(); }
interface Checkbox { void paint(); }

// Concrete "Products" for Windows
class WindowsButton implements Button {
    public void paint() { System.out.println("Rendering a Windows-style button."); }
}
class WindowsCheckbox implements Checkbox {
    public void paint() { System.out.println("Rendering a Windows-style checkbox."); }
}

// Concrete "Products" for macOS
class MacOSButton implements Button {
    public void paint() { System.out.println("Rendering a macOS-style button."); }
}
class MacOSCheckbox implements Checkbox {
    public void paint() { System.out.println("Rendering a macOS-style checkbox."); }
}

// The Abstract Factory interface
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factories
class WindowsFactory implements GUIFactory {
    public Button createButton() { return new WindowsButton(); }
    public Checkbox createCheckbox() { return new WindowsCheckbox(); }
}
class MacOSFactory implements GUIFactory {
    public Button createButton() { return new MacOSButton(); }
    public Checkbox createCheckbox() { return new MacOSCheckbox(); }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Depending on the OS, we create a different factory.
//     GUIFactory factory = new MacOSFactory(); // Or new WindowsFactory();
//     Button button = factory.createButton();
//     Checkbox checkbox = factory.createCheckbox();
    
//     button.paint();
//     checkbox.paint();
// }
```

---

### 4. The Builder Pattern

*   **The Core Problem (The "Why"):** "I need to construct a complex object with many fields, some of which are optional. Using a constructor with a huge list of parameters is messy and error-prone (a 'telescoping constructor')."
*   **The Solution (The "How"):** Separate the construction of a complex object from its representation. You use a separate `Builder` object that handles the step-by-step construction. This often involves a fluent interface where you can chain method calls.
*   **Analogy:** Ordering a custom sandwich at Subway. You don't tell the cashier your entire order in one long sentence. You tell the sandwich artist (the `Builder`) each step: "Use this bread," "add this meat," "add these veggies," "use this sauce." At the end, you call `.build()` to get your final `Sandwich` object.
*   **When to Use It:** When an object's constructor would have too many parameters, or when the object needs to be built in distinct stages. It greatly improves readability.

**Code Example (Java):**
```java
// The complex "Product" we want to build
class Computer {
    // Required parameters
    private String cpu;
    private String ram;
    // Optional parameters
    private String storage;
    private String graphicsCard;

    // The constructor is private so you MUST use the builder
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.graphicsCard = builder.graphicsCard;
    }
    
    @Override public String toString() { /* ... for printing ... */ }

    // The static inner Builder class
    public static class Builder {
        private String cpu; // required
        private String ram; // required
        private String storage; // optional
        private String graphicsCard; // optional

        public Builder(String cpu, String ram) {
            this.cpu = cpu;
            this.ram = ram;
        }

        public Builder setStorage(String storage) {
            this.storage = storage;
            return this; // Return the builder for method chaining
        }

        public Builder setGraphicsCard(String graphicsCard) {
            this.graphicsCard = graphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Build a basic computer
//     Computer gamingPC = new Computer.Builder("Intel i9", "32GB")
//                             .setStorage("1TB SSD")
//                             .setGraphicsCard("NVIDIA RTX 4090")
//                             .build();

//     // Build an office computer with no graphics card
//     Computer officePC = new Computer.Builder("Intel i5", "16GB")
//                             .setStorage("512GB SSD")
//                             .build();
// }
```

---

### 5. The Prototype Pattern

*   **The Core Problem (The "Why"):** "I need to create a new object that is an exact copy of an existing object, but creating it from scratch is very slow, complex, or resource-intensive."
*   **The Solution (The "How"):** Create new objects by cloning an existing instance (the "prototype"). Instead of creating a new object, you ask the prototype to make a copy of itself.
*   **Analogy:** Making copies of a key. You don't describe the key's shape, depth, and cuts to the locksmith. You just give them the original key (the prototype), and they create a perfect clone. It's much faster and more reliable.
*   **When to Use It:** When the cost of creating a new object is more expensive than cloning it, or when you want to create a set of "template" objects that you can copy and modify.

**Code Example (Java):**
```java
// The Prototype interface requires a clone method
// (Java's built-in Cloneable is a "marker" interface)
abstract class Shape implements Cloneable {
    String color;
    
    abstract void draw();

    @Override
    public Object clone() {
        Object clone = null;
        try {
            clone = super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }
}

// Concrete Prototypes
class Circle extends Shape {
    public Circle() { this.color = "Red"; }
    void draw() { System.out.println("Drawing a circle."); }
}
class Rectangle extends Shape {
    public Rectangle() { this.color = "Blue"; }
    void draw() { System.out.println("Drawing a rectangle."); }
}

// A registry to store our prototype objects
class ShapeRegistry {
    private static java.util.Map<String, Shape> shapeMap = new java.util.HashMap<>();

    public static Shape getShape(String shapeId) {
        Shape cachedShape = shapeMap.get(shapeId);
        return (Shape) cachedShape.clone(); // Return a clone, not the original
    }

    public static void loadCache() {
        shapeMap.put("circle", new Circle());
        shapeMap.put("rectangle", new Rectangle());
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     ShapeRegistry.loadCache();
    
//     Shape clonedCircle = ShapeRegistry.getShape("circle");
//     clonedCircle.draw();
    
//     Shape clonedRectangle = ShapeRegistry.getShape("rectangle");
//     clonedRectangle.draw();
// }
```

---

### Structural Design Patterns (Part 1)

If Creational Patterns are about how objects are "born," then Structural Patterns are about how they are **composed and organized** into larger, more flexible structures.

Think of it this way: you have your building materials (your objects). Structural patterns are the architectural blueprints that show you how to assemble those materials to build a wall, a room, or an entire house. They define the relationships between objects.

Today, we'll focus on four foundational structural patterns.

---

### 1. The Adapter Pattern

*   **The Core Problem (The "Why"):** "I have a class I want to use (e.g., from a third-party library), but its interface doesn't match the interface my application expects. I can't change the library's code, so how do I make them work together?"
*   **The Solution (The "How"):** You create an **Adapter** class that "wraps" the incompatible object. This adapter implements the interface your application expects and internally translates the calls into the format the wrapped object understands.
*   **Analogy (The Classic):** A **travel power adapter**. Your laptop's US plug is the interface your application knows. The European wall socket is the incompatible object you need to use. The power adapter sits in between, connecting the two seamlessly. Your laptop doesn't even know it's plugged into a European socket; it only sees the adapter.
*   **When to Use It:**
    *   When you need to use an existing class but its interface is incompatible with the rest of your code.
    *   When you are working with legacy code or third-party libraries that you cannot modify.

**Code Example (Java):**

```java
// The interface your application's client code expects to use.
interface ModernWeatherService {
    double getTemperatureInCelsius();
}

// The legacy, incompatible class you have to work with.
class LegacyWeatherApi {
    // It returns temperature in Fahrenheit.
    public double getTempInF() {
        return 77.0; // e.g., 77°F
    }
}

// The Adapter class that makes them compatible.
class WeatherAdapter implements ModernWeatherService {
    private LegacyWeatherApi legacyApi;

    public WeatherAdapter(LegacyWeatherApi legacyApi) {
        this.legacyApi = legacyApi;
    }

    @Override
    public double getTemperatureInCelsius() {
        // 1. Get the data from the legacy API in its format (Fahrenheit).
        double tempInF = legacyApi.getTempInF();

        // 2. Translate it to the format our application expects (Celsius).
        double tempInC = (tempInF - 32) * 5.0 / 9.0;
        
        return tempInC;
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     LegacyWeatherApi legacyApi = new LegacyWeatherApi();
//     ModernWeatherService adapter = new WeatherAdapter(legacyApi);
    
//     // The client code interacts with the modern interface, unaware of the legacy system.
//     double temp = adapter.getTemperatureInCelsius();
//     System.out.println("Current temperature: " + temp + "°C"); // Outputs approx. 25.0°C
// }
```

---

### 2. The Bridge Pattern

*   **The Core Problem (The "Why"):** "I have two independent dimensions of variation in my classes (e.g., shape and color, or remote control and device). If I use inheritance, I'll get a 'class explosion.' For example, `RedCircle`, `BlueCircle`, `RedSquare`, `BlueSquare`. How can I decouple these dimensions so they can vary independently?"
*   **The Solution (The "How"):** Decouple an abstraction from its implementation. You create two separate class hierarchies: one for the **abstraction** (e.g., `Shape`) and one for the **implementation** (e.g., `Color`). The abstraction contains a reference to an implementation object.
*   **Analogy:** A TV remote control. The **abstraction** is the remote itself (you could have a `BasicRemote` or a `SmartRemote`). The **implementation** is the device it controls (a `SonyTV` or a `SamsungTV`). The remote holds a reference to the TV. This way, you can develop new remotes without touching the TV code, and develop new TVs without touching the remote code. You can mix and match them.
*   **When to Use It:**
    *   When you want to avoid a permanent binding between an abstraction and its implementation.
    *   When both the abstractions and their implementations can be extended by subclassing. This is a design decision you make *upfront* to keep things flexible.

**Code Example (Java):**

```java
// The "Implementor" interface for the implementation hierarchy.
interface DrawingAPI {
    void drawCircle(double x, double y, double radius);
}

// Concrete Implementors
class DrawingAPIV1 implements DrawingAPI {
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("APIv1.circle at %f:%f radius %f\n", x, y, radius);
    }
}
class DrawingAPIV2 implements DrawingAPI {
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("APIv2.circle at %f:%f radius %f\n", x, y, radius);
    }
}

// The "Abstraction" in the abstraction hierarchy.
abstract class Shape {
    protected DrawingAPI drawingAPI; // The bridge!
    protected Shape(DrawingAPI drawingAPI) { this.drawingAPI = drawingAPI; }
    public abstract void draw();
}

// A "Refined Abstraction"
class Circle extends Shape {
    private double x, y, radius;
    public Circle(double x, double y, double radius, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x; this.y = y; this.radius = radius;
    }

    public void draw() {
        drawingAPI.drawCircle(x, y, radius);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     Shape redCircle = new Circle(1, 2, 3, new DrawingAPIV1());
//     Shape blueCircle = new Circle(5, 7, 11, new DrawingAPIV2());

//     redCircle.draw();  // Uses APIv1
//     blueCircle.draw(); // Uses APIv2
// }
```

---

### 3. The Composite Pattern

*   **The Core Problem (The "Why"):** "I need to build a system that has a tree-like structure (e.g., a file system, a company org chart, a graphical drawing with grouped shapes), and I want to treat individual objects and groups of objects in the exact same way."
*   **The Solution (The "How"):** Create a common interface for both individual objects (called "leaves") and groups of objects (called "composites"). A composite object simply holds a collection of other components (which can be leaves or other composites) and delegates operations to them.
*   **Analogy:** A file system. A `Folder` is a composite, and a `File` is a leaf. You can perform an operation like `calculateSize()` on a single `File` or on an entire `Folder`. When you call `calculateSize()` on a folder, it iterates through all its contents (files and sub-folders) and asks them for their size, summing them up. The client code doesn't need to care if it's dealing with one file or a directory of a thousand files.
*   **When to Use It:**
    *   When you want to represent part-whole hierarchies of objects.
    *   When you want clients to be able to treat individual objects and compositions of objects uniformly.

**Code Example (Java):**

```java
import java.util.ArrayList;
import java.util.List;

// The common "Component" interface for both leaves and composites.
interface Graphic {
    void print();
}

// The "Leaf" node. It has no children.
class Circle implements Graphic {
    public void print() { System.out.println("Circle"); }
}

// The "Composite" node. It contains a collection of other Graphics.
class CompoundGraphic implements Graphic {
    private List<Graphic> children = new ArrayList<>();

    public void add(Graphic child) { children.add(child); }
    public void remove(Graphic child) { children.remove(child); }

    public void print() {
        System.out.println("CompoundGraphic:");
        for (Graphic child : children) {
            child.print();
        }
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Create a complex drawing
//     CompoundGraphic all = new CompoundGraphic();
//     all.add(new Circle());
//     all.add(new Circle());

//     // Create a sub-group
//     CompoundGraphic group = new CompoundGraphic();
//     group.add(new Circle());
//     group.add(new Circle());

//     all.add(group); // Add the sub-group to the main drawing

//     // The client code treats the entire complex drawing as a single object.
//     all.print();
// }
```

---

### 4. The Decorator Pattern

*   **The Core Problem (The "Why"):** "I need to add new functionality or responsibilities to an object, but I want to do it at runtime, without creating a giant mess of subclasses for every possible combination."
*   **The Solution (The "How"):** Create "decorator" classes that wrap the original object. These decorators share the same interface as the object they wrap. When a method is called on the decorator, it adds its own behavior and then delegates the call to the wrapped object. You can stack decorators on top of each other.
*   **Analogy:** Ordering a coffee. You start with a plain `Coffee` object (the component). To add milk, you wrap it in a `MilkDecorator`. To also add sugar, you wrap the `MilkDecorator` in a `SugarDecorator`. Each decorator adds to the final cost and description of the object it's wrapping, forming a "stack" of features.
*   **When to Use It:**
    *   To add responsibilities to individual objects dynamically and transparently, without affecting other objects.
    *   When subclassing is impractical due to the sheer number of independent extensions.

**Code Example (Java):**

```java
// The "Component" interface.
interface Notifier {
    void send(String message);
}

// The "Concrete Component".
class EmailNotifier implements Notifier {
    public void send(String message) {
        System.out.println("Sending email: " + message);
    }
}

// The base "Decorator" class.
abstract class NotifierDecorator implements Notifier {
    protected Notifier wrappedNotifier;
    public NotifierDecorator(Notifier notifier) { this.wrappedNotifier = notifier; }

    public void send(String message) {
        wrappedNotifier.send(message);
    }
}

// "Concrete Decorators"
class SMSNotifierDecorator extends NotifierDecorator {
    public SMSNotifierDecorator(Notifier notifier) { super(notifier); }
    @Override
    public void send(String message) {
        super.send(message); // First, do the original notification
        sendSMS(message);    // Then, add the new functionality
    }
    private void sendSMS(String message) { System.out.println("Sending SMS: " + message); }
}
class SlackNotifierDecorator extends NotifierDecorator {
    public SlackNotifierDecorator(Notifier notifier) { super(notifier); }
    @Override
    public void send(String message) {
        super.send(message);

        sendSlack(message);
    }
    private void sendSlack(String message) { System.out.println("Sending Slack message: " + message); }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Start with a basic email notifier.
//     Notifier notifier = new EmailNotifier();

//     // Now, wrap it with decorators to add functionality.
//     notifier = new SMSNotifierDecorator(notifier);
-    notifier = new SlackNotifierDecorator(notifier);

//     // This single call will now trigger email, SMS, and Slack notifications.
//     notifier.send("Your package has been shipped!");
// }
```

---

### 5. The Facade Pattern

*   **The Core Problem (The "Why"):** "I'm working with a complex subsystem that has many moving parts and a confusing interface. I just want to perform a simple, common task without having to understand and manage all the underlying complexity myself."
*   **The Solution (The "How"):** You create a single `Facade` class that provides a simple, high-level interface to the complex subsystem. The facade delegates the client's requests to the appropriate objects within the subsystem. The client interacts only with the facade, not with the dozens of classes behind it.
*   **Analogy (The Classic):** The **ignition key of a car**. When you turn the key, a complex chain of events happens: the battery is engaged, the fuel pump is activated, the starter motor turns the engine, the spark plugs fire, etc. You, the driver, don't care about any of that. The ignition system provides a simple facade (`turnKey()`) that hides all that complexity from you.
*   **When to Use It:**
    *   When you want to provide a simple interface to a complex subsystem.
    *   When you want to decouple your client code from the internal implementation of a subsystem, making it easier to change or upgrade the subsystem later.

**Code Example (Java):**

```java
// --- The Complex Subsystem ---
class AudioSystem {
    void turnOn() { System.out.println("Audio System ON"); }
    void setSource(String source) { System.out.println("Setting source to " + source); }
    void setVolume(int level) { System.out.println("Setting volume to " + level); }
}
class VideoSystem {
    void turnOn() { System.out.println("Projector ON"); }
    void setInput(String input) { System.out.println("Setting projector input to " + input); }
}
class LightingSystem {
    void dim(int level) { System.out.println("Dimming lights to " + level + "%"); }
}

// --- The Facade Class ---
class HomeTheaterFacade {
    private AudioSystem audio;
    private VideoSystem video;
    private LightingSystem lighting;

    public HomeTheaterFacade(AudioSystem audio, VideoSystem video, LightingSystem lighting) {
        this.audio = audio;
        this.video = video;
        this.lighting = lighting;
    }

    // A simple method that coordinates the complex subsystem.
    public void watchMovie(String movie) {
        System.out.println("Get ready to watch a movie...");
        lighting.dim(10);
        video.turnOn();
        video.setInput("Blu-ray");
        audio.turnOn();
        audio.setSource("Blu-ray");
        audio.setVolume(20);
        System.out.println("Playing movie: " + movie);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Create the subsystem components
//     AudioSystem audio = new AudioSystem();
//     VideoSystem video = new VideoSystem();
//     LightingSystem lighting = new LightingSystem();

//     // Create the Facade
//     HomeTheaterFacade homeTheater = new HomeTheaterFacade(audio, video, lighting);

//     // The client makes one simple call.
//     homeTheater.watchMovie("Inception");
// }
```

---

### 6. The Flyweight Pattern

*   **The Core Problem (The "Why"):** "I need to create a massive number of objects, but they share a lot of common data. Creating a full object for each instance would consume a huge amount of memory and be very slow."
*   **The Solution (The "How"):** Separate the shared, unchanging state of an object (called **intrinsic** state) from its unique, context-dependent state (called **extrinsic** state). The intrinsic state is stored in a shared "flyweight" object. When you need an object, you pass the extrinsic state to the flyweight's methods. A factory is often used to manage and return shared flyweight objects.
*   **Analogy:** The characters in a word processor. Every time you type the letter 'A', you don't create a new object that stores the font, size, and shape of 'A'. That data (the intrinsic state) is stored **once**. The only things that are unique are the character's position on the page and its color (the extrinsic state). The application reuses the single 'A' flyweight object everywhere, just applying different contextual information.
*   **When to Use It:**
    *   When an application uses a large number of objects.
    *   When most of an object's state can be made extrinsic (moved outside the object).
    *   When a large portion of the objects can be replaced by a few shared objects.

**Code Example (Java):**

```java
import java.util.HashMap;
import java.util.Map;

// The Flyweight interface
interface TreeType {
    void draw(int x, int y); // Extrinsic state is passed in
}

// The Concrete Flyweight (stores the intrinsic state)
class OakTreeType implements TreeType {
    private final String texture = "OakTexture"; // Intrinsic state (shared)
    private final String color = "Brown";        // Intrinsic state (shared)

    public void draw(int x, int y) {
        System.out.printf("Drawing an Oak tree at (%d, %d) with texture %s\n", x, y, texture);
    }
}

// The Flyweight Factory
class TreeFactory {
    private static Map<String, TreeType> treeTypes = new HashMap<>();

    public static TreeType getTreeType(String typeName) {
        TreeType type = treeTypes.get(typeName);
        if (type == null) {
            if (typeName.equals("Oak")) {
                type = new OakTreeType();
                treeTypes.put("Oak", type);
                System.out.println("--- Created a new Oak flyweight object ---");
            }
            // ... could have other tree types like "Pine"
        }
        return type;
    }
}

// The Context class (stores the extrinsic state)
class Tree {
    private int x, y;          // Extrinsic state
    private TreeType type;     // Reference to the shared flyweight

    public Tree(int x, int y, TreeType type) {
        this.x = x; this.y = y; this.type = type;
    }

    public void draw() {
        type.draw(x, y);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     // We want to draw a forest of 10 Oak trees
//     for (int i = 0; i < 10; i++) {
//         TreeType oakType = TreeFactory.getTreeType("Oak"); // The factory ensures we only have one OakType object
//         Tree tree = new Tree(i, i * 2, oakType);
//         tree.draw();
//     }
// }
// The output will show "--- Created a new Oak flyweight object ---" only once!
```

---

### 7. The Proxy Pattern

*   **The Core Problem (The "Why"):** "I need to provide a substitute or placeholder for another object to control access to it. For example, I need to add security checks, lazy initialization, or logging without modifying the original object."
*   **The Solution (The "How"):** Create a `Proxy` object that has the same interface as the real object (the "Subject"). The client interacts with the Proxy as if it were the real object. The Proxy can then handle the request itself or delegate it to the real object, adding its own logic before or after.
*   **Analogy:** A **credit card**. A credit card is a proxy for your bank account. It provides the same interface (`spendMoney()`), but it adds a layer of control. It can perform security checks (is the PIN correct?), handle network communication, and log transactions. You don't interact directly with your pile of cash (the real object); you use the convenient and secure proxy.
*   **When to Use It:**
    *   **Virtual Proxy:** For lazy initialization of expensive objects. The proxy creates the real object only when it's first needed.
    *   **Protection Proxy:** To control access based on permissions.
    *   **Remote Proxy:** To represent an object that exists in a different memory space (e.g., on a server).
    *   **Logging Proxy:** To log calls to the real object's methods.

**Code Example (Java - Protection Proxy):**

```java
// The "Subject" interface
interface Internet {
    void connectTo(String serverHost) throws Exception;
}

// The "Real Subject"
class RealInternet implements Internet {
    public void connectTo(String serverHost) {
        System.out.println("Connecting to " + serverHost);
    }
}

// The "Proxy" class
class ProxyInternet implements Internet {
    private Internet internet = new RealInternet();
    private static List<String> bannedSites = new ArrayList<>();

    static {
        bannedSites.add("banned.com");
        bannedSites.add("danger.net");
    }

    public void connectTo(String serverHost) throws Exception {
        // Add protection logic before delegating
        if (bannedSites.contains(serverHost.toLowerCase())) {
            throw new Exception("Access Denied: This site is banned!");
        }
        
        internet.connectTo(serverHost);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     Internet internet = new ProxyInternet(); // The client uses the Proxy, not the RealInternet
//     try {
//         internet.connectTo("google.com");
//         internet.connectTo("banned.com");
//     } catch (Exception e) {
//         System.out.println(e.getMessage());
//     }
// }
```

---

### Behavioral Design Patterns (Part 1)

We've covered how to create objects (Creational) and how to organize them (Structural). Behavioral patterns are all about **how objects communicate and assign responsibilities**.

These patterns provide elegant solutions for managing algorithms, relationships, and the flow of control in your applications. They help you create systems where components are loosely coupled, flexible, and communicate effectively.

Today, we'll start with four of the most influential patterns in this category.

---

### 1. The Strategy Pattern

*   **The Core Problem (The "Why"):** "I have a task that can be performed in several different ways (i.e., different algorithms), and I want my main class to be able to switch between these algorithms at runtime without being coupled to their specific implementations."
*   **The Solution (The "How"):** You define a family of algorithms, encapsulate each one in its own separate class (the "Strategy"), and make them interchangeable. The main class (the "Context") holds a reference to a strategy object and delegates the actual work to it.
*   **Analogy (The Classic):** A **map application**. When you ask for directions, the app is the "Context." You can choose your mode of transport, which sets the `Strategy`: a `DrivingStrategy`, a `WalkingStrategy`, or a `PublicTransitStrategy`. The app simply calls a `calculateRoute()` method on whichever strategy object is currently active. You can swap strategies on the fly.
*   **When to Use It:**
    *   When you have many related classes that differ only in their behavior.
    *   When you need different variations of an algorithm.
    *   When you want to avoid exposing complex, algorithm-specific data structures to the client.

**Code Example (Java):**

```java
// The Strategy interface defines the action.
interface CompressionStrategy {
    void compress(String filePath);
}

// Concrete Strategies implementing the interface.
class ZipCompressionStrategy implements CompressionStrategy {
    public void compress(String filePath) {
        System.out.println("Compressing " + filePath + " using ZIP algorithm.");
    }
}
class RarCompressionStrategy implements CompressionStrategy {
    public void compress(String filePath) {
        System.out.println("Compressing " + filePath + " using RAR algorithm.");
    }
}

// The Context class that uses a strategy.
class FileCompressor {
    private CompressionStrategy strategy;

    public FileCompressor(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    // Allows changing the strategy at runtime.
    public void setStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void compressFile(String filePath) {
        // The context delegates the work to the strategy object.
        strategy.compress(filePath);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     FileCompressor compressor = new FileCompressor(new ZipCompressionStrategy());
//     compressor.compressFile("my_document.txt"); // Outputs: Compressing ... using ZIP...

//     // Switch strategy at runtime.
//     compressor.setStrategy(new RarCompressionStrategy());
//     compressor.compressFile("my_document.txt"); // Outputs: Compressing ... using RAR...
// }
```

---

### 2. The Observer Pattern

*   **The Core Problem (The "Why"):** "I have one object (the 'Subject') whose state changes, and I need multiple other objects (the 'Observers') to be notified and updated automatically whenever that change happens. The subject shouldn't have to know anything about its observers."
*   **The Solution (The "How"):** Define a subscription mechanism. The `Subject` object maintains a list of its `Observer` objects. When an event occurs or its state changes, the subject iterates through its list of observers and calls an `update()` method on each one.
*   **Analogy:** A **YouTube channel subscription**. The YouTuber (the `Subject`) doesn't know you personally. They just have a list of subscribers (`Observers`). When they upload a new video (a state change), the YouTube platform automatically sends a notification to every single subscriber on the list.
*   **When to Use It:**
    *   When a change in one object requires changing others, and you don't know how many objects need to be changed.
    *   When you want to establish a one-to-many dependency between objects without making them tightly coupled.

**Code Example (Java):**

```java
import java.util.ArrayList;
import java.util.List;

// The Observer interface.
interface NewsObserver {
    void update(String news);
}

// The Subject class.
class NewsAgency {
    private String news;
    private List<NewsObserver> observers = new ArrayList<>();

    public void addObserver(NewsObserver observer) {
        observers.add(observer);
    }
    public void removeObserver(NewsObserver observer) {
        observers.remove(observer);
    }
    
    // When the state changes, notify all observers.
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }

    private void notifyObservers() {
        for (NewsObserver observer : observers) {
            observer.update(this.news);
        }
    }
}

// Concrete Observers.
class NewsChannel implements NewsObserver {
    private String channelName;
    public NewsChannel(String name) { this.channelName = name; }

    @Override
    public void update(String news) {
        System.out.println("[" + channelName + "] Breaking News: " + news);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     NewsAgency agency = new NewsAgency();
//     agency.addObserver(new NewsChannel("CNN"));
//     agency.addObserver(new NewsChannel("BBC"));

//     agency.setNews("Global markets are rallying!"); // Both channels will report this.
// }
```

---

### 3. The Command Pattern

*   **The Core Problem (The "Why"):** "I need to issue a request to an object, but I want to decouple the object that issues the request from the object that performs the action. I also want to be able to queue requests, log them, or make them undoable."
*   **The Solution (The "How"):** Encapsulate a request as an object. This `Command` object contains all the information needed to perform an action, including a reference to the receiver of the action and the method to call.
*   **Analogy:** A **restaurant order ticket**. A customer (the `Client`) creates an order (the `Command`). The waiter (the `Invoker`) takes the order ticket and places it on the queue. The chef (the `Receiver`) picks up the ticket and executes the command (cooks the food). The waiter doesn't need to know how to cook; they just need to handle the command object. The tickets can be queued, logged, or even cancelled.
*   **When to Use It:**
    *   When you want to parameterize objects with an action to perform.
    *   To implement callback mechanisms, queues, and undo/redo functionality.

**Code Example (Java):**

```java
// The Receiver - the object that performs the actual work.
class Light {
    public void turnOn() { System.out.println("The light is on."); }
    public void turnOff() { System.out.println("The light is off."); }
}

// The Command interface.
interface Command {
    void execute();
}

// Concrete Commands that encapsulate a request.
class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    public void execute() { light.turnOn(); }
}
class LightOffCommand implements Command {
    private Light light;
    public LightOffCommand(Light light) { this.light = light; }
    public void execute() { light.turnOff(); }
}

// The Invoker - the object that triggers the command.
class RemoteControl {
    private Command command;
    public void setCommand(Command command) { this.command = command; }
    public void pressButton() { command.execute(); }
}

// --- Usage ---
// public static void main(String[] args) {
//     Light livingRoomLight = new Light();
//     RemoteControl remote = new RemoteControl();

//     // Configure the remote with the "turn on" command
//     remote.setCommand(new LightOnCommand(livingRoomLight));
//     remote.pressButton(); // Outputs: The light is on.

//     // Re-configure the remote with the "turn off" command
//     remote.setCommand(new LightOffCommand(livingRoomLight));
//     remote.pressButton(); // Outputs: The light is off.
// }
```

---

### 4. The Template Method Pattern

*   **The Core Problem (The "Why"):** "I have an algorithm that consists of a series of steps. The overall structure of the algorithm is fixed, but I want to allow subclasses to redefine or customize some of the specific steps without changing the algorithm's structure."
*   **The Solution (The "How"):** Define the skeleton of an algorithm in a method in a parent class (the "template method"). This method calls a series of other methods. The steps that are fixed are implemented in the parent, while the steps that can be customized are declared as `abstract`, forcing subclasses to provide their own implementation.
*   **Analogy:** A **standardized process for building a house**. The parent `HouseBuilder` class has a `buildHouse()` template method that defines the required sequence: `layFoundation()`, `buildWalls()`, `addRoof()`, `installWindows()`. The `layFoundation()` step is the same for all houses and is implemented in the parent class. However, `buildWalls()` and `addRoof()` are abstract, so a `BrickHouse` subclass will implement them differently than a `WoodenHouse` subclass. The sequence of steps, however, cannot be changed.
*   **When to Use It:**
    *   To implement the invariant parts of an algorithm once and leave it up to subclasses to implement the behavior that can vary.
    *   When you have several classes that contain almost identical algorithms with some minor differences.

**Code Example (Java):**

```java
// The abstract class with the template method.
abstract class GameAI {
    // This is the Template Method. It's final to prevent subclasses from changing the sequence.
    public final void takeTurn() {
        collectResources();
        buildStructures();
        attack();
        sendScouts();
    }

    // Some steps are common to all AI.
    protected void collectResources() {
        System.out.println("Collecting resources...");
    }
    
    // Other steps must be implemented by subclasses.
    protected abstract void buildStructures();
    protected abstract void attack();

    // A "hook" method - subclasses can override it, but it's not required.
    protected void sendScouts() {
        // Default behavior is to do nothing.
    }
}

// Concrete subclasses that customize the variable steps.
class OrcAI extends GameAI {
    @Override
    protected void buildStructures() {
        System.out.println("Building Orcish burrows and barracks.");
    }
    @Override
    protected void attack() {
        System.out.println("Orcs are attacking with axes!");
    }
}
class ElfAI extends GameAI {
    @Override
    protected void buildStructures() {
        System.out.println("Building Elven halls of wood and leaf.");
    }
    @Override
    protected void attack() {
        System.out.println("Elves are attacking with bows and arrows!");
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     GameAI orc = new OrcAI();
//     orc.takeTurn();

//     System.out.println("---");

//     GameAI elf = new ElfAI();
//     elf.takeTurn();
// }
```

---
### Behavioral Design Patterns (Part 2)

We've covered how to encapsulate algorithms and manage notifications and requests. Now, we'll explore patterns that help objects traverse data structures, change their behavior based on their internal state, and communicate in a more organized way.

### 5. The Iterator Pattern

*   **The Core Problem (The "Why"):** "I have a collection of objects (like a list, a tree, or a custom data structure), and I need to provide a way to access its elements sequentially without exposing the underlying structure of the collection."
*   **The Solution (The "How"):** You separate the traversal logic from the collection itself into a separate `Iterator` object. The collection provides a method to get an iterator. The iterator object keeps track of the current position in the traversal and knows how to access the next element.
*   **Analogy (The Classic):** A **TV remote's "next channel" and "previous channel" buttons**. You, the user, don't need to know if the TV stores its channels in a list, an array, or some other complex structure. The remote (the `Iterator`) provides a simple interface (`hasNext()`, `next()`) that hides all that complexity, allowing you to move through the channels one by one.
*   **When to Use It:**
    *   When you want to provide a uniform way to traverse different data structures.
    *   To simplify the interface of a complex collection.
    *   To allow multiple traversals to happen on the same collection simultaneously.

**Code Example (Java):**
(Note: Java has a built-in `java.util.Iterator` interface, which this pattern is based on. We'll build a simplified version to show the concept.)
```java
// The Iterator interface
interface Iterator<T> {
    boolean hasNext();
    T next();
}

// The Aggregate (Collection) interface
interface StationList {
    Iterator<RadioStation> createIterator();
}

// A concrete object to be iterated over
class RadioStation {
    private float frequency;
    public RadioStation(float frequency) { this.frequency = frequency; }
    public float getFrequency() { return frequency; }
}

// A concrete Aggregate (Collection)
class ConcreteStationList implements StationList {
    private java.util.List<RadioStation> stations = new java.util.ArrayList<>();
    
    public void addStation(RadioStation station) { stations.add(station); }
    
    @Override
    public Iterator<RadioStation> createIterator() {
        return new StationIterator(this.stations);
    }
    
    // The Concrete Iterator, often as a private inner class
    private class StationIterator implements Iterator<RadioStation> {
        private java.util.List<RadioStation> stationList;
        private int position = 0;

        public StationIterator(java.util.List<RadioStation> list) { this.stationList = list; }

        @Override
        public boolean hasNext() {
            return position < stationList.size();
        }

        @Override
        public RadioStation next() {
            RadioStation station = stationList.get(position);
            position++;
            return station;
        }
    }
}


// --- Usage ---
// public static void main(String[] args) {
//     ConcreteStationList stationList = new ConcreteStationList();
//     stationList.addStation(new RadioStation(89.1f));
//     stationList.addStation(new RadioStation(94.5f));
//     stationList.addStation(new RadioStation(102.7f));

//     Iterator<RadioStation> iterator = stationList.createIterator();
//     while (iterator.hasNext()) {
//         RadioStation station = iterator.next();
//         System.out.println("Playing station: " + station.getFrequency() + " MHz");
//     }
// }
```

---

### 6. The State Pattern

*   **The Core Problem (The "Why"):** "I have an object that needs to change its behavior dramatically when its internal state changes. If I use a giant `if/else` or `switch` statement in every method to check the current state, my code will become a complex, unmanageable mess."
*   **The Solution (The "How"):** You create separate classes for each possible state and encapsulate all the behavior for that state within its own class. The main object (the "Context") holds a reference to a `State` object that represents its current state. When an action is requested, the context delegates the action to its current state object. The state objects themselves are responsible for transitioning the context to a new state.
*   **Analogy:** A **vending machine**. The machine behaves differently depending on its state. In the `NoCoinState`, pressing a button does nothing. After you insert a coin, it transitions to the `HasCoinState`. Now, pressing a button will dispense an item and transition it to the `SoldState` (or back to `NoCoinState`). Each state handles the button press in its own unique way.
*   **When to Use It:**
    *   When an object's behavior depends on its state, and it must change its behavior at runtime depending on that state.
    *   When you have massive conditional statements that check the object's current state.

**Code Example (Java):**

```java
// The Context class
class Document {
    private State currentState;
    public Document() { this.currentState = new DraftState(this); }
    public void changeState(State state) { this.currentState = state; }
    public void render() { this.currentState.render(); }
    public void publish() { this.currentState.publish(); }
}

// The State interface
interface State {
    void render();
    void publish();
}

// Concrete State classes
class DraftState implements State {
    private Document document;
    public DraftState(Document doc) { this.document = doc; }

    public void render() { System.out.println("Rendering a draft document..."); }
    public void publish() {
        System.out.println("Moving from Draft to Moderation...");
        document.changeState(new ModerationState(document));
    }
}

class ModerationState implements State {
    private Document document;
    public ModerationState(Document doc) { this.document = doc; }
    
    public void render() { System.out.println("Rendering a document in moderation..."); }
    public void publish() {
        System.out.println("Publishing the document!");
        document.changeState(new PublishedState(document));
    }
}

class PublishedState implements State {
    private Document document;
    public PublishedState(Document doc) { this.document = doc; }

    public void render() { System.out.println("Rendering a published document."); }
    public void publish() { System.out.println("Action not allowed: Document is already published."); }
}


// --- Usage ---
// public static void main(String[] args) {
//     Document doc = new Document();
//     doc.render(); // Renders as draft

//     doc.publish(); // Moves to moderation
//     doc.render(); // Renders as in moderation

//     doc.publish(); // Moves to published
//     doc.render(); // Renders as published
//     doc.publish(); // Action not allowed
// }
```

---

### 7. The Mediator Pattern

*   **The Core Problem (The "Why"):** "I have a group of objects that need to communicate with each other, but letting them all reference each other directly creates a 'spaghetti code' nightmare. Every object is tightly coupled to every other object, making the system impossible to change."
*   **The Solution (The "How"):** You create a central `Mediator` object that handles all the communication between the other objects (called "Colleagues"). Colleagues no longer talk to each other directly; they only send notifications to and receive requests from the Mediator. This decouples the colleagues from one another.
*   **Analogy:** An **air traffic control tower**. Airplanes (Colleagues) don't communicate directly with each other to coordinate landings and takeoffs—that would be chaos. Instead, they all communicate with the central control tower (the `Mediator`). The tower knows the status of all planes and directs them accordingly, preventing collisions.
*   **When to Use It:**
    *   When a set of objects communicate in complex but well-defined ways.
    *   When you want to reuse individual components, but they are too dependent on other components.

**Code Example (Java):**

```java
// The Mediator interface
interface ChatMediator {
    void sendMessage(String msg, User user);
    void addUser(User user);
}

// The Colleague class (or interface)
abstract class User {
    protected ChatMediator mediator;
    protected String name;
    public User(ChatMediator med, String name) { this.mediator = med; this.name = name; }
    public abstract void send(String msg);
    public abstract void receive(String msg);
}

// A Concrete Mediator
class ChatMediatorImpl implements ChatMediator {
    private java.util.List<User> users = new java.util.ArrayList<>();
    
    @Override
    public void addUser(User user) { this.users.add(user); }
    
    @Override
    public void sendMessage(String msg, User sender) {
        for (User u : this.users) {
            // A user should not receive their own message
            if (u != sender) {
                u.receive(msg);
            }
        }
    }
}

// Concrete Colleagues
class UserImpl extends User {
    public UserImpl(ChatMediator med, String name) { super(med, name); }
    
    @Override
    public void send(String msg) {
        System.out.println(this.name + ": Sending Message = " + msg);
        mediator.sendMessage(msg, this);
    }
    @Override
    public void receive(String msg) {
        System.out.println(this.name + ": Received Message: " + msg);
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     ChatMediator mediator = new ChatMediatorImpl();
//     User user1 = new UserImpl(mediator, "Alice");
//     User user2 = new UserImpl(mediator, "Bob");
//     User user3 = new UserImpl(mediator, "Charlie");
    
//     mediator.addUser(user1);
//     mediator.addUser(user2);
//     mediator.addUser(user3);

//     user1.send("Hi everyone!"); // Bob and Charlie will receive the message
// }
```

### Behavioral Design Patterns (Part 3)

We've covered a wide range of patterns for how objects can collaborate. This final session will introduce the remaining patterns, giving you a complete toolkit for managing object behavior and communication in any scenario.

---

### 8. The Memento Pattern

*   **The Core Problem (The "Why"):** "I need to capture the internal state of an object from the outside, so I can restore it later. However, I must do this without breaking the object's encapsulation (i.e., without making all its fields public)."
*   **The Solution (The "How"):** The pattern has three participants:
    1.  **Originator:** The object whose state we want to save. It has a method to create a `Memento` and a method to restore its state from a `Memento`.
    2.  **Memento:** A simple object that stores the state of the Originator. It should be an "opaque token"—the outside world shouldn't be able to inspect its contents.
    3.  **Caretaker:** The object that holds onto the Memento. It's responsible for keeping the memento safe, but it never modifies or inspects it.
*   **Analogy:** The **"Save Game" functionality**. The game itself (the `Originator`) creates a save file (the `Memento`). You, the player (the `Caretaker`), decide when and where to save this file. Later, you can give the save file back to the game, and the game knows how to restore its state from it. You can't open the save file and edit your character's stats directly; it's an opaque object to you.
*   **When to Use It:**
    *   To implement checkpoints, undo/redo functionality, or transactional operations.
    *   When direct access to an object's state would violate its encapsulation.

**Code Example (Java):**

```java
// The Memento object - stores the state.
class Memento {
    private final String state; // final makes it immutable
    public Memento(String stateToSave) { this.state = stateToSave; }
    public String getSavedState() { return state; }
}

// The Originator object - creates and uses mementos.
class Editor {
    private String content;
    public void type(String words) { this.content = words; }
    public String getContent() { return content; }

    public Memento save() {
        return new Memento(this.content);
    }
    public void restore(Memento memento) {
        this.content = memento.getSavedState();
    }
}

// The Caretaker object - holds onto mementos.
class History {
    private java.util.Stack<Memento> mementos = new java.util.Stack<>();
    public void push(Memento memento) { mementos.push(memento); }
    public Memento pop() { return mementos.pop(); }
}

// --- Usage ---
// public static void main(String[] args) {
//     Editor editor = new Editor();
//     History history = new History();

//     editor.type("This is the first sentence.");
//     history.push(editor.save()); // Save the state

//     editor.type("This is the second sentence.");
//     history.push(editor.save()); // Save the state again

//     editor.type("This is the third sentence.");
//     System.out.println("Current content: " + editor.getContent());

//     // Now, let's undo.
//     editor.restore(history.pop()); // Restore to second sentence
//     System.out.println("After undo: " + editor.getContent());

//     editor.restore(history.pop()); // Restore to first sentence
//     System.out.println("After second undo: " + editor.getContent());
// }
```

---

### 9. The Chain of Responsibility Pattern

*   **The Core Problem (The "Why"):** "I have a request that needs to be processed, but I don't know which object should handle it. I want to avoid coupling the sender of a request to its receiver."
*   **The Solution (The "How"):** You create a chain of handler objects. Each handler has a reference to the next handler in the chain. When a request comes in, the first handler inspects it. If it can process the request, it does so. If not, it passes the request along to the next handler in the chain. This continues until the request is handled or the end of the chain is reached.
*   **Analogy:** A **customer support system**. A request first goes to a Level 1 `Operator`. If they can't handle it (e.g., it's a technical bug), they pass it up to a Level 2 `Technician`. If it's a billing issue, the Technician might pass it to a `BillingManager`. The initial sender doesn't care who ultimately solves the problem; they just send it into the chain.
*   **When to Use It:**
    *   When more than one object can handle a request, and the handler isn't known beforehand.
    *   When you want to issue a request to one of several objects without specifying the receiver explicitly.

**Code Example (Java):**

```java
// The Handler abstract class
abstract class Approver {
    protected Approver nextApprover;
    public void setNext(Approver approver) { this.nextApprover = approver; }
    public abstract void processRequest(Purchase purchase);
}

class Purchase {
    private int number; private double amount; private String purpose;
    public Purchase(int num, double amt, String pur) { this.number = num; this.amount = amt; this.purpose = pur; }
    public double getAmount() { return amount; }
}

// Concrete Handlers
class Manager extends Approver {
    public void processRequest(Purchase purchase) {
        if (purchase.getAmount() < 500) {
            System.out.println("Manager approved purchase #" + purchase.getAmount());
        } else if (nextApprover != null) {
            nextApprover.processRequest(purchase);
        }
    }
}
class Director extends Approver {
    public void processRequest(Purchase purchase) {
        if (purchase.getAmount() < 5000) {
            System.out.println("Director approved purchase #" + purchase.getAmount());
        } else if (nextApprover != null) {
            nextApprover.processRequest(purchase);
        }
    }
}
class VicePresident extends Approver {
    public void processRequest(Purchase purchase) {
        if (purchase.getAmount() < 25000) {
            System.out.println("Vice President approved purchase #" + purchase.getAmount());
        } else {
            System.out.println("Purchase #" + purchase.getAmount() + " requires executive meeting!");
        }
    }
}

// --- Usage ---
// public static void main(String[] args) {
//     // Build the chain
//     Manager manager = new Manager();
//     Director director = new Director();
//     VicePresident vp = new VicePresident();
//     manager.setNext(director);
//     director.setNext(vp);

//     // Process requests
//     manager.processRequest(new Purchase(1, 350.00, "Supplies"));
//     manager.processRequest(new Purchase(2, 4200.00, "Laptops"));
//     manager.processRequest(new Purchase(3, 30000.00, "New Server Farm"));
// }
```

---

### 10. The Visitor Pattern

*   **The Core Problem (The "Why"):** "I have a complex object structure (like a Composite tree), and I need to perform a new operation on all the elements. However, I want to add this new operation without changing the classes of the elements themselves."
*   **The Solution (The "How"):** You separate the new operation into a distinct `Visitor` class. You then add a single `accept(visitor)` method to each element class. When `accept()` is called on an element, the element immediately calls a corresponding `visit()` method on the visitor, passing a reference to itself (`this`). This allows the visitor to perform its operation on that specific element type.
*   **Analogy:** A **tax inspector visiting different businesses**. The businesses (the `Elements` like a `Restaurant`, a `Shop`, a `Factory`) are part of the city's structure. A tax inspector (the `Visitor`) knows how to calculate taxes for each type of business. The inspector `visits` each business. The business `accepts` the visitor and says, "Here I am, a Restaurant. Do your restaurant tax calculation on me." This allows you to add a new `HealthInspector` visitor later without ever changing the `Restaurant` or `Shop` classes.
*   **When to Use It:**
    *   When you have an object structure and you need to perform many different and unrelated operations on it.
    *   When you need to add a new operation to classes but are unable or unwilling to change them.

**Code Example (Java):**

```java
// The Visitor interface
interface Visitor {
    void visit(Book book);
    void visit(Fruit fruit);
}

// The Element interface
interface ItemElement {
    void accept(Visitor visitor);
}

// Concrete Elements
class Book implements ItemElement {
    private int price; private String isbnNumber;
    public Book(int p, String isbn) { this.price = p; this.isbnNumber = isbn; }
    public int getPrice() { return price; }
    public void accept(Visitor visitor) { visitor.visit(this); }
}
class Fruit implements ItemElement {
    private int pricePerKg; private int weight;
    public Fruit(int p, int w) { this.pricePerKg = p; this.weight = w; }
    public int getPrice() { return pricePerKg * weight; }
    public void accept(Visitor visitor) { visitor.visit(this); }
}

// Concrete Visitor
class ShoppingCartVisitor implements Visitor {
    private int totalCost = 0;
    public void visit(Book book) { totalCost += book.getPrice(); }
    public void visit(Fruit fruit) { totalCost += fruit.getPrice(); }
    public int getTotalCost() { return totalCost; }
}

// --- Usage ---
// public static void main(String[] args) {
//     ItemElement[] items = new ItemElement[]{new Book(20, "1234"), new Fruit(10, 2)};
//     ShoppingCartVisitor visitor = new ShoppingCartVisitor();
//     for(ItemElement item : items){
//         item.accept(visitor);
//     }
//     System.out.println("Total Cost = " + visitor.getTotalCost()); // Outputs: 40
// }
```

---

### 11. The Interpreter Pattern

*   **The Core Problem (The "Why"):** "I need to process structured textual commands or expressions. The language has a clear grammar, and I need a way to parse and evaluate sentences written in it."
*   **The Solution (The "How"):** You define a class for each rule (terminal and non-terminal) in your language's grammar. You then represent a sentence in the language as an Abstract Syntax Tree (AST) made up of instances of these classes. An `interpret()` method on each class evaluates that part of the tree.
*   **Analogy:** A musician reading **sheet music**. The sheet music is the language with a defined grammar (notes, rests, time signatures). The musician is the `Interpreter`. They parse the language rule by rule ("this is a C quarter note") and execute the corresponding action (play a C for one beat).
*   **When to Use It:** This pattern is highly specialized. Use it when you have a simple language to interpret and can represent sentences as an AST. Examples include processing configuration files, simple query languages, or regular expressions. It is often overkill for complex languages where a dedicated parser generator (like ANTLR) is better.

*(Note: A full code example for Interpreter is often long and complex. A conceptual explanation is more valuable for initial learning.)*

---
